clear
addpath('/isilon/LFMI/VMdrive/Thomas/NaturalisticAuditorySequences_ToneDuration(NAS_TD)/ECoG/Experiment_Versions/sfa_expt4_Adeen_Current/stim_creation/TestThomas_CreateTrainingStim/')
load series_selection_H.01_beta.99_1000.mat %load pre-computed series
%content: 1000 constructed tone series
    %series_r = tone series (1:33), values in non-logHz form
    %series_pred = p*34 predicted final tones

betas = {0.5 0.99 1.5};

%% 1. Series selection:
%%% sort the vectors in ascending order; 
%for the experimental stimuli, the first 5, middle 5, and last 5 were selected
%for training, we select 5+x, middle 5+-x, and top -x
for i_b = 3 %we only want highest beta (1.5)
    beta = betas{i_b};
    sorted_series_pred_r = sort(series_pred_r{i_b}); %sort p*34 vals
     
    %select p*34 from low/medium/high position (after, beside, before
    %experimental vals)
    num_experimental_series = 5; %number of series already selected for experiment
    num_training_series = 3; %number of series (per trend) we want to determine for training 
    
    [minVals minInds] = intersect(series_pred_r{i_b},sorted_series_pred_r...
        (num_experimental_series+1:num_experimental_series+num_training_series));
    [maxVals maxInds] = intersect(series_pred_r{i_b},sorted_series_pred_r...
        ((length(sorted_series_pred_r)-(num_experimental_series+num_training_series-1)):(length(sorted_series_pred_r)-num_experimental_series)));
    if mod(num_training_series,2) == 1 %odd number of num_training_series
    [medVals medInds] = intersect(series_pred_r{i_b},sorted_series_pred_r...
        ([(500-floor(num_experimental_series/2))-floor(num_training_series/2):(500-ceil(num_experimental_series/2)),...
        (500+ceil(num_experimental_series/2)):(500+ceil(num_experimental_series/2))+ floor(num_training_series/2)]));
    else %even number of num_training_series
    [medVals medInds] = intersect(series_pred_r{i_b},sorted_series_pred_r...
        ([(500-floor(num_experimental_series/2))-floor(num_training_series/2):(500-ceil(num_experimental_series/2)),...
        (500+ceil(num_experimental_series/2)):(500+floor(num_experimental_series/2))+ floor(num_training_series/2)]));
    end 
    
    inds = [minInds' medInds' maxInds']; %copy indeces of selected sequences

    %read out respective tone sequences corresponding to selected p*34
    series_rp{i_b}      = series_r{i_b}(inds',:);
    series_pred_rp{i_b} = series_pred_r{i_b}(inds',:);
    pred_err_rp{i_b}    = pred_err_r{i_b}(inds',:);

% % plot the ranges for the series generated by converging_prediction
% % alongside the desired range value
% figure; hold on;
% plot([mean(ranges) mean(ranges)],[0 300],'g-','LineWidth',3)
% plot([r_target r_target],[0 300],'r-','LineWidth',3)
% hist(ranges);
% % set(h,'XScale','log');
% plot([mean(ranges) mean(ranges)],[0 300],'g-','LineWidth',3)
% plot([r_target r_target],[0 300],'r-','LineWidth',3)
% 
% legend('mean range value','desired range value');
% title(['distribution of ranges, beta = ' num2str(beta)]);
% xlabel('range')

% plot the ranges for the series generated by converging_prediction
% alongside the desired range value
% % % % figure; hold on;
% % % % h=20;
% % % % plot([median(ranges) median(ranges)],[0 h],'g-','LineWidth',2)
% % % % plot([r_target r_target],[0 h],'r-','LineWidth',2)
% % % % hist(ranges);
% % % % % set(h,'XScale','log');
% % % % plot([median(ranges) median(ranges)],[0 h],'g-','LineWidth',2)
% % % % plot([r_target r_target],[0 h],'r-','LineWidth',2)
% % % % 
% % % % legend(['median range value = ' num2str(median(ranges))],['desired range value = ' num2str((r_target))]);
% % % % title(['distribution of ranges (log scale), beta = ' num2str(beta) ', sigma2 = ' num2str(sigma2)]);
% % % % xlabel('range (log scale)')

% % plot the series that have ranges within r_delta of r_target
% figure; hold on;
% for j=1:sum(inRange)
%     plot(1:k,series_r{i_b}(j,:),'b-');
%     plot(k+1,series_pred_r{i_b}(j),'r.');
% end
% title(['selected for range, beta = ' num2str(beta)])


% plot the individual series that have ranges within r_delta of r_target
% and have the max, min, and median series prediction values
figure;
col_down(1:num_training_series) = {'r'};
col_med(1:num_training_series) = {'g'};
col_up(1:num_training_series) = {'b'};
col = [col_down, col_med, col_up];
% col = {'r' 'r' 'r' 'r' 'g' 'g' 'g' 'g' 'b' 'b' 'b' 'b' 'b'};
for j = 1:length(inds)
subplot(3,num_training_series,j); hold on;
    hold on
    plot(1:k, series_rp{i_b}(j,:), [col{j} '-'],'LineWidth',2);
    plot(k+1, series_pred_rp{i_b}(j), [col{j} '*'], 'MarkerSize',5);
    
    if j <= length(minInds)
    title(['downward trend, beta = ' num2str(beta) ',series# = ' num2str(inds(j))])
    elseif j > length(minInds) && j <= length(minInds)+length(medInds)
    title(['medium trend, beta = ' num2str(beta) ',series# = ' num2str(inds(j))])
    elseif j > length(minInds)+length(medInds)
    title(['upward trend, beta = ' num2str(beta) ',series# = ' num2str(inds(j))])
    end
end


end
% cd '\\gogo.sb.nyumc.org\data\gogodisk4\thomas\AuditoryPrediction\iEEG\Experiment_Versions\sfa_expt4_Adeen_Current\stim_creation\TestThomas_CreateTrainingStim\';
% save('seriesselection_3trials_per_predp34_TJB.mat','series_rp','series_pred_rp','pred_err_rp');

%% 2. Series scaling to Hz
load(['/isilon/LFMI/VMdrive/Thomas/NaturalisticAuditorySequences_ToneDuration(NAS_TD)/ECoG/Experiment_Versions/sfa_expt4_Adeen_Current/stim_creation/TestThomas_CreateTrainingStim/','seriesselection_3trials_per_predp34_TJB.mat'])

% define allowable tone frequencies
maxFreq       = 880*2;
nOctaves      = 4;
toneRange     = [maxFreq/2^nOctaves maxFreq]; 
nTonesInRange = 12*nOctaves+1; 
logToneFreqs  = linspace(log(toneRange(1)), log(toneRange(2)), nTonesInRange);

betas = [0 0.99 1.5];
k = 33;

% scale series to Hz scale centered on 440 Hz and discretize
for i_b = 3%1:length(betas)
    for i_s = 1:size(series_rp{i_b},1) %loop over series

        mean_adj = log(440); %log freq 440 Hz for penultimate tone
        
        %add logfreq 440Hz to all tones of series and p*34 to center all tones on freq 440Hz
        series_logHz{i_b}(i_s,:)       = series_rp{i_b}(i_s,:) + mean_adj;

        series_pred_logHz{i_b}(i_s,1)  = series_pred_rp{i_b}(i_s,1) + mean_adj;
        
        
        discr = 1;
        if discr
            % discretize log frequencies (i.e., replaces logfreq with the log of that possible tone freq that is closest)
            %so that each element takes one of 25 values evenly spaced on
            %the log scale with semitone distance            
            
            for i_tone = 1:length(series_logHz{i_b})
                [d, ix] = min( abs(series_logHz{i_b}(i_s,i_tone)-logToneFreqs) );
                series_discretIndex{i_b}(i_s,i_tone) = ix;
            end
            [d, ix] = min( abs(series_pred_logHz{i_b}(i_s)-logToneFreqs) );
            series_pred_discretIndex{i_b}(i_s) = ix;
            
%             %Old way - does not work because discretize doesn't take the
%             %exact values but the one left/right of it
%             series_logHz{i_b}(i_s,:)       = discretize(series_logHz{i_b}(i_s,:), logToneFreqs);
%             series_pred_logHz{i_b}(i_s,:)  = discretize(series_pred_logHz{i_b}(i_s,:), logToneFreqs);

        end
              
        % re-define final tone (p34) frequency in HZ (tf_Hz) using discretized offsets
        xx = [6 12]; %number of semitones that p34 can vary from 440 Hz (in our new version 6 or 12 semitones)
        nSemitones_offsets = [-xx(end:-1:1) xx];

        ss = series_discretIndex{i_b}(i_s,end); %read out position of 440 Hz (penultimate tone) in logToneFreq rarray 
        [m ind] = min( abs(ss - logToneFreqs(13:37)) ); %read out index in logToneFreq of tone corresponding to log(440Hz) in the range from log(220Hz) to log(440Hz) 
        for i_x = 1:length(nSemitones_offsets)
            %read out discretized freqs for all possible p34 option (i.e.,
            %+-3 semitones from 440 Hz)
            series_logHz_tf_Hz{i_b}(i_s,i_x) = logToneFreqs(ind + nSemitones_offsets(i_x)); 
        end
        
            %Get discretized logfreq value (from above index)
            series_logHz{i_b}(i_s,:) = logToneFreqs(series_discretIndex{i_b}(i_s,:));
            series_pred_logHz{i_b}(i_s,:) = logToneFreqs(series_pred_discretIndex{i_b}(i_s));        
        
        %transform to Hz (from logHz)
        series_Hz{i_b}(i_s,:)        = exp(series_logHz{i_b}(i_s,:));

        series_Hz_tf_Hz{i_b}(i_s,:)  = exp(series_logHz_tf_Hz{i_b}(i_s,:));

        series_pred_Hz{i_b}(i_s,1)   = exp(series_pred_logHz{i_b}(i_s,1));

    end
end

% Hz plot
figure;
i_p = 1;
for i_b = 3%1:length(betas)
    for i_s = 1:size(series_rp{i_b},1)
        subplot(3,3,i_p); hold on;
        title(['t_f by logHz, beta = ' num2str(betas(i_b))])
        
        plot(1:k, series_Hz{i_b}(i_s,:), 'b-');
        plot(k+1, series_pred_Hz{i_b}(i_s), 'ro');
        plot(k+1, series_Hz_tf_Hz{i_b}(i_s,:),'r.');
        
        plot(1:k, 220*ones(1,k), 'r-');
        plot(1:k, 880*ones(1,k), 'r-');
        
        i_p = i_p + 1;
    end
end

% logHz plot
figure;
i_p = 1;
for i_b = 3%length(betas)
    for i_s = 1:size(series_rp{i_b},1)
        subplot(3,3,i_p); hold on;
        title(['t_f by logHz, beta = ' num2str(betas(i_b))])
        
        plot(1:k, series_logHz{i_b}(i_s,:), 'b-');
        plot(k+1, series_pred_logHz{i_b}(i_s), 'ro');
        plot(k+1, series_logHz_tf_Hz{i_b}(i_s,:),'r.');
        
%         plot(1:k, series_logHz_sc{i_b}(i_s,:), 'g-');
%         plot(k+1, series_pred_logHz_sc{i_b}(i_s), 'ko');
%         plot(k+1, series_logHz_sc_tf_Hz{i_b}(i_s,:),'k.');
        
        plot(1:k, log(220)*ones(1,k), 'r-');
        plot(1:k, log(880)*ones(1,k), 'r-');
        
        i_p = i_p + 1;
    end
end

%%Test
%Dot-Line plot for all 9 sequences (to act as instructions)
figd;
i_p = 1;
x_fin = [34 34 34 34];
for i_b = 3
    for i_s = 1:size(series_rp{i_b},1)
        subplot(3,3,i_p); hold on;

        if i_p < 4
            SeqTrend = 'Down';
        elseif i_p < 7
            SeqTrend = 'Medium';
        else 
            SeqTrend = 'Up';
        end
            
        title(['Training Seq #' num2str(i_p) '; Trend: ' SeqTrend])       
        
        plot([0 34], [log(440) log(440)], '--', 'color', [0.4 0.4 0.4])

        %plot seq
%         plot(1:k, series_logHz{i_b}(i_s,:), 'b.-', 'MarkerSize', 15);
%         plot(k+1, series_pred_logHz{i_b}(i_s), 'bo');
%         plot(k+1, series_logHz_tf_Hz{i_b}(i_s,:),'k.');        

        plot(1:k, series_logHz{i_b}(i_s,:), 'Marker', '.', 'Color', 'k','MarkerSize',30);
        hold on;
        plot(k+1, series_pred_logHz{i_b}(i_s), 'Marker', 'd', 'Color', 'r','MarkerSize',10,'MarkerFaceColor','r');
        hold on;
        scatter(x_fin,series_logHz_tf_Hz{i_b}(i_s,:), 80,'o', 'filled', 'b');

        hold on
        xlim([1 34])
        ylim([log(220) log(880)])        
        
%         plot(1:k, log(220)*ones(1,k), 'r-');
%         plot(1:k, log(880)*ones(1,k), 'r-');        
        
        %Y-axis
        if i_p == 1 || i_p == 4 || i_p == 7 %left bound
            ylabel('Tone Pitch (log Hz)')            
            set(gca,'YTick',[5.5 6 6.5 7]);
        else
            ylabel('') 
            set(gca,'YTick',[]);           
        end
        
        %Xaxis
        if i_p == 7 || i_p == 8 || i_p == 9 %botttom bound
            xlabel('Tone Number')
            set(gca,'XTick',[5 10 15 20 25 30]);
        else
            xlabel('') 
            set(gca,'XTick',[]);   
        end
        
        i_p = i_p + 1; %Counter
    end
end
suptitle(['Training Sequences in logHz (beta = ' num2str(betas(i_b)) ')'])       



%double selected sequences, because we want to present them 2 times
series_Hz{i_b} = [series_Hz{i_b}; series_Hz{i_b}];
series_Hz_tf_Hz{i_b} = [series_Hz_tf_Hz{i_b}; series_Hz_tf_Hz{i_b}];
series_pred_Hz{i_b} = [series_pred_Hz{i_b}; series_pred_Hz{i_b}];
series_logHz{i_b} = [series_logHz{i_b}; series_logHz{i_b}];
series_pred_logHz{i_b} = [series_pred_logHz{i_b}; series_pred_logHz{i_b}];
%close all
cd '\\gogo.sb.nyumc.org\data\gogodisk4\thomas\AuditoryPrediction\iEEG\Experiment_Versions\sfa_expt4_Adeen_Current\stim_creation\TestThomas_CreateTrainingStim\';
save('seriesselection4training_9x2seqs_3pertrend_beta1.5_TJB.mat','series_logHz', 'series_pred_logHz','series_Hz','series_Hz_tf_Hz','series_pred_Hz');

